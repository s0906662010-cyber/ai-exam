<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ExamVision — 監考動作分析 Demo</title>
  <style>
    body { font-family: -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif; padding: 12px; background:#f7f9fc; text-align:center; }
    header { margin-bottom:8px; }
    video, canvas { width: 100%; max-width:480px; border:1px solid #ddd; border-radius:8px; display:block; margin:10px auto; background:black; }
    #controls { max-width:480px; margin:8px auto; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    button, select { padding:10px 12px; border-radius:8px; border: none; background:#0078ff; color:white; font-weight:600; cursor:pointer; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    #log { width:100%; max-width:480px; margin:10px auto; text-align:left; background:white; padding:8px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.04); min-height:60px;}
    .frame-result { border-bottom:1px dashed #eee; padding:6px 0; }
    img.thumb { width:160px; border:1px solid #ddd; margin-top:6px; }
  </style>

  <!-- MediaPipe CDN (用於偵測 face & hands) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
  <header>
    <h1>弊弊在目-考試監測做弊率分析系統</h1>
    <p>按切換即可改變鏡頭，按「擷取幀」拍照並分析（示範用途）。</p>
  </header>

  <video id="video" playsinline autoplay muted></video>
  <canvas id="overlay"></canvas>

 <div id="controls">
  <label for="cameraSelect" style="align-self:center; color:#333;">鏡頭：</label>
  <select id="cameraSelect"></select>
  <button id="switchBtn">切換鏡頭</button>
  <button id="captureBtn">拍攝並分析</button>
</div>

  <div id="log">狀態：尚未啟動</div>

<script>
(async () => {
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const cameraSelect = document.getElementById('cameraSelect');
  const switchBtn = document.getElementById('switchBtn');
  const captureBtn = document.getElementById('captureBtn');
  const startAutoBtn = document.getElementById('startAutoBtn');
  const logEl = document.getElementById('log');

  let currentStream = null;
  let currentDeviceId = null;
  let devices = [];
  let camera; // MediaPipe Camera wrapper (we'll control lifecycle)
  let faceMesh, hands;
  let latestFace = null, latestHand = null;

  // ---------- helpers ----------
  function log(msg, append=true){
    if(append) logEl.innerHTML += `<div>${msg}</div>`;
    else logEl.innerHTML = `<div>${msg}</div>`;
  }
  function clearLog(){ logEl.innerHTML = ''; }

  function stopStream(){
    if(currentStream){
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
    if(camera){
      try{ camera.stop(); }catch(e){}
      camera = null;
    }
  }

  // 取得裝置清單並填入下拉選單
  async function enumerateCameras(){
    try {
      const list = await navigator.mediaDevices.enumerateDevices();
      devices = list.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      devices.forEach(d => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        // 如果 label 不可見（須先允許相機）就用 generic name
        opt.text = d.label || `Camera ${cameraSelect.length+1}`;
        cameraSelect.appendChild(opt);
      });
      if(devices.length) {
        currentDeviceId = devices[0].deviceId;
        cameraSelect.value = currentDeviceId;
      }
    } catch(e){
      console.error("enumerateDevices error", e);
    }
  }

  // 啟動攝影機（根據 deviceId 或 facingMode）
  async function startCamera(deviceId = null){
    stopStream();
    const constraints = deviceId ? { video: { deviceId: { exact: deviceId } } } : { video: { facingMode: 'user' } };
    try {
      currentStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = currentStream;
      await video.play();

      // MediaPipe 初始化（只做一次）
      if(!faceMesh){
        faceMesh = new FaceMesh.FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
        faceMesh.setOptions({ maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(r => { latestFace = r; drawOverlay(); });
      }
      if(!hands){
        hands = new Hands.Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(r => { latestHand = r; drawOverlay(); });
      }

      // Camera util 交由 MediaPipe 控制連續傳影格
      camera = new Camera(video, {
        onFrame: async () => {
          // 每一影格都送去 MediaPipe（即時更新 latestFace/latestHand）
          await faceMesh.send({image: video});
          await hands.send({image: video});
        },
        width: 640,
        height: 480
      });
      camera.start();

      clearLog();
      log('相機啟動，正在偵測……', false);
      await enumerateCameras(); // 更新下拉（取得 labels 需要權限）
    } catch (e) {
      console.error("startCamera error", e);
      log('錯誤：無法啟動相機，請確保已允許相機權限並在 HTTPS 下。');
    }
  }

  function drawOverlay(){
    if(!overlay.width) {
      overlay.width = video.videoWidth || 640;
      overlay.height = video.videoHeight || 480;
    }
    const ctx = overlay.getContext('2d');
    ctx.clearRect(0,0,overlay.width,overlay.height);
    if(latestFace && latestFace.multiFaceLandmarks){
      for(const lm of latestFace.multiFaceLandmarks){
        drawConnectors(ctx, lm, FaceMesh.FACEMESH_TESSELATION, {color:'#c0c0c0', lineWidth:0.5});
        drawLandmarks(ctx, lm, {color:'#ff0000', lineWidth:1, radius:0.8});
      }
    }
    if(latestHand && latestHand.multiHandLandmarks){
      for(const lm of latestHand.multiHandLandmarks){
        drawConnectors(ctx, lm, Hands.HAND_CONNECTIONS, {color:'#00aa00', lineWidth:2});
        drawLandmarks(ctx, lm, {color:'#00ff00', lineWidth:1, radius:1});
      }
    }
  }

  // 影像分析邏輯（同你原本的分析概念）
  function analyzeFrame(faceResults, handResults){
    const out = { timestamp: Date.now(), faces:0, events:[], score:0 };
    if(faceResults && faceResults.multiFaceLandmarks){
      out.faces = faceResults.multiFaceLandmarks.length;
      faceResults.multiFaceLandmarks.forEach((lm, idx) => {
        const leftEye = lm[33], rightEye = lm[263], nose = lm[1];
        if(leftEye && rightEye && nose){
          const eyeMidX = (leftEye.x + rightEye.x)/2;
          const dx = nose.x - eyeMidX;
          if(dx > 0.03){ out.events.push({type:'head_right', idx, severity: Math.min(1, dx/0.08)}); out.score += 15*Math.min(1, dx/0.08); }
          if(dx < -0.03){ out.events.push({type:'head_left', idx, severity: Math.min(1, Math.abs(dx)/0.08)}); out.score += 15*Math.min(1, Math.abs(dx)/0.08); }
        }
      });
    }
    if(handResults && handResults.multiHandLandmarks && faceResults && faceResults.multiFaceLandmarks){
      handResults.multiHandLandmarks.forEach((handLm) => {
        const hx = handLm[9].x, hy = handLm[9].y;
        for(let i=0;i<faceResults.multiFaceLandmarks.length;i++){
          const nose = faceResults.multiFaceLandmarks[i][1];
          const dx = hx - nose.x, dy = hy - nose.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if(dist < 0.12){ out.events.push({type:'hand_near_head', faceIndex:i, severity: Math.max(0,1-dist/0.12)}); out.score += 25*Math.max(0,1-dist/0.12); }
        }
      });
    }
    if(out.faces >= 2){ out.events.push({type:'multiple_faces', count: out.faces}); out.score += 20*(out.faces-1); }
    out.score = Math.max(0, Math.min(100, Math.round(out.score)));
    return out;
  }

  // 擷取快照（回傳 base64 image + analysis）
  function captureSnapshot(){
    const tmp = document.createElement('canvas');
    tmp.width = video.videoWidth || 640;
    tmp.height = video.videoHeight || 480;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(video, 0, 0, tmp.width, tmp.height);
    const dataUrl = tmp.toDataURL('image/jpeg', 0.8);
    // 深拷貝 results 確保 immutability
    const faceR = latestFace ? JSON.parse(JSON.stringify(latestFace)) : null;
    const handR = latestHand ? JSON.parse(JSON.stringify(latestHand)) : null;
    const analysis = analyzeFrame(faceR, handR);
    analysis.image = dataUrl;
    return analysis;
  }

  function renderResult(res, idx){
    const div = document.createElement('div');
    div.className = 'frame-result';
    const ts = new Date(res.timestamp).toLocaleTimeString();
    div.innerHTML = `<strong>第 ${idx+1} 幀</strong> — ${ts} — 可疑指標: ${res.score}
      <div>人數：${res.faces}</div>
      <div>事件：${res.events.length?res.events.map(e=>e.type+'('+ (e.severity?Math.round(e.severity*100)/100:'') +')').join(', '):'無'}</div>
      <div style="margin-top:6px;"><img class="thumb" src="${res.image}"/></div>`;
    logEl.prepend(div); // 最新放上面
  }

  // ---------- UI handlers ----------
  cameraSelect.addEventListener('change', async (e) => {
    currentDeviceId = e.target.value;
    await startCamera(currentDeviceId);
  });

  switchBtn.addEventListener('click', async () => {
    if(devices.length < 2){
      alert('此裝置只有一個相機，無法切換。');
      return;
    }
    // 找到另一個 camera id（簡單切換）
    const idx = devices.findIndex(d => d.deviceId === currentDeviceId);
    const next = devices[(idx + 1) % devices.length];
    currentDeviceId = next.deviceId;
    cameraSelect.value = currentDeviceId;
    await startCamera(currentDeviceId);
  });

  captureBtn.addEventListener('click', () => {
    const r = captureSnapshot();
    renderResult(r, 0);
  });

  startAutoBtn.addEventListener('click', async () => {
    startAutoBtn.disabled = true;
    captureBtn.disabled = true;
    log('開始自動擷取 5 幀（每 5 秒一幀）……', false);
    const results = [];
    for(let i=0;i<5;i++){
      await new Promise(r => setTimeout(r, i===0?300:5000));
      const res = captureSnapshot();
      renderResult(res, i);
      results.push(res);
    }
    // 結束
    log('自動擷取完成（請人工審核結果）');
    startAutoBtn.disabled = false;
    captureBtn.disabled = false;
  });


  
  // ---------- 初始化：先啟動 camera（使用預設前鏡頭） ----------
  await startCamera(); // 預設會使用 facingMode: 'user' 或第一個 device

  // 當頁面關閉時清理資源
  window.addEventListener('beforeunload', () => { stopStream(); });

})();
</script>
</body>
</html>
